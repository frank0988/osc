# 工具前Y，_保已安b aarch64-linux-gnu 工具
CC = aarch64-linux-gnu-gcc
LD = aarch64-linux-gnu-ld
OBJCOPY = aarch64-linux-gnu-objcopy

# gx
CFLAGS = -Wall -ffreestanding -nostdinc -nostdlib -nostartfiles -Ibootloader
# BYx，使用您提供的 linker.ld
LDFLAGS = -T bootloader/linker.ld

# 原始a路
SRC_DIR = bootloader
BUILD_DIR = build

# ふ宜有 .c 和 .s n案
C_SRCS = $(wildcard $(SRC_DIR)/*.c)
S_SRCS = $(wildcard $(SRC_DIR)/*.s)
OBJS = $(patsubst $(SRC_DIR)/%.c, $(BUILD_DIR)/%.o, $(C_SRCS)) \
       $(patsubst $(SRC_DIR)/%.s, $(BUILD_DIR)/%.o, $(S_SRCS))

# 目n案名Q
BOOTLOADER_IMG = bootloader.img
BOOTLOADER_ELF = $(BUILD_DIR)/bootloader.elf

.PHONY: all clean run

all: $(BOOTLOADER_IMG)

# 建立g目Kg C n案
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# 建立g目Kg Assembly n案
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.s
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# BYK生成二M位影像n
$(BOOTLOADER_IMG): $(OBJS)
	$(LD) $(LDFLAGS) $(OBJS) -o $(BOOTLOADER_ELF)
	$(OBJCOPY) -O binary $(BOOTLOADER_ELF) $(BOOTLOADER_IMG)

# y Bootloader 的 QEMU 指令
# 使用 -serial pty 以便 python _本B
run: $(BOOTLOADER_IMG)
	qemu-system-aarch64 -M raspi3b \
		-kernel $(BOOTLOADER_IMG) \
		-display none \
		-serial null -serial pty
debug: $(BOOTLOADER_IMG)
	qemu-system-aarch64 -M raspi3b \
		-kernel $(BOOTLOADER_IMG) \
		-display none \
		-serial null -serial pty \
		-S -s

# 清除ga物:
clean:
	rm -rf $(BUILD_DIR) $(BOOTLOADER_IMG)

test:
	qemu-system-aarch64 -M raspi3b \
        -kernel $(BOOTLOADER_IMG) \
        -display none \
        -serial null -serial stdio
runpy: 
		python3 host/sendimg.py
